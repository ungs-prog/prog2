#+TITLE: Práctica 0
#+SETUPFILE: .level.org
#+OPTIONS: num:1
#+PROPERTY: header-args :mkdirp yes

#+TOC: headlines 1


* Pilas y colas
:PROPERTIES:
:CUSTOM_ID: ej1
:HTML_CONTAINER_CLASS: ejercicios
:header-args: :noweb-ref Ejercicio1 :noweb-sep "\n\n"
:END:

*Archivo:* [[file:src/ungs/prog2/tp0/Ejercicio1.java][Ejercicio1.java]].

a. Implementar una función que reciba una [[#ColaInt][cola de enteros]] e invierta el orden
   de sus elementos.
   # (0.5 pts.)

   #+BEGIN_SRC java
   public static void invertirCola(ColaInt cola) {
       // Ayuda: usar una Pila como estructura auxiliar.
   }
   #+END_SRC

b. Implementar una función que reciba una [[#PilaInt][pila de enteros]] e invierta el orden
   de sus elementos.
   # (0.5 pts.)

   #+BEGIN_SRC java
   public static void invertirPila(PilaInt pila) {
   }
   #+END_SRC

c. Implementar una variante de ~invertirPila()~ que devuelva la pila invertida en
   lugar de modificar la original.
   # (1 pt.)

   #+BEGIN_SRC java
   public static PilaInt pilaInversa(PilaInt pila) {
       // Ayuda: se puede desapilar de la pila original si luego queda en su
       // orden original al retornar de la función.
       return null;
   }
   #+END_SRC

d. Implementar una función que reciba dos colas de enteros ordenadas y devuelva
   una tercera cola que sea la unión de las dos, y siga ordenada.
   # (1 pt.)

   Las colas originales deben quedar vacías, y /no/ se permite el uso de
   estructuras auxiliares.

   #+BEGIN_SRC java
   public static ColaInt combinarOrdenadas(ColaInt c1, ColaInt c2) {
       return null;
   }
   #+END_SRC

   Ejemplo:

   #+BEGIN_EXAMPLE
   1.ª cola: 4 7 9 15 35 39
   2.ª cola: 1 2 5 9 14 30 50

   Resultado:

       1 2 4 5 7 9 9 14 15 30 35 39 50
   #+END_EXAMPLE

e. /(Opcional)/ Implementar una versión de /PilaInt/ sobre un arreglo de enteros
   con redimensionamiento dinámico.

   Archivo adicional que se debe entregar: [[file:src/ungs/prog2/tp0/opcional/PilaArr.java][PilaArr.java]].

   #+BEGIN_SRC java :tangle prog2/tp0/opcional/PilaArr.java :exports none :noweb-ref none :mkdirp yes
   package ungs.prog2.tp0.opcional;

   public class PilaArr
   {
       // Ejercicio OPCIONAL. Cambiar RESUELTO a ‘true’ en caso de
       // implementarlo.
       public static final boolean RESUELTO = false;

       public static final int TAM_INICIAL = 8;
       public static final int FACTOR_REDIM = 2;

       private int[] elems;
       // ...

       public PilaArr() {
           elems = new int[TAM_INICIAL];
           // ...
       }

       public void apilar(int x) {
           // Duplicar el tamaño del arreglo si no queda espacio.
       }

       public int desapilar() {
           // Dividir por ‘FACTOR_REDIM’ el tamaño del arreglo si hay
           // un 75% de espacio, pero sin bajar de ‘TAM_INICIAL’.
           return -1;
       }

       public int tope() {
           return -1;
       }

       public boolean vacia() {
           return false;
       }
   }
   #+END_SRC


* Recursión
:PROPERTIES:
:CUSTOM_ID: ej2
:HTML_CONTAINER_CLASS: ejercicios
:header-args: :noweb-ref Ejercicio2 :noweb-sep "\n\n"
:END:

*Archivo:* [[file:src/ungs/prog2/tp0/Ejercicio2.java][Ejercicio2.java]].

a. Implementar una función recursiva de búsqueda binaria sobre un arreglo
   ordenado de enteros.
   # (1 pt.)

   #+BEGIN_SRC java
   // Devuelve la posición del entero buscado, o -1 si no se encontró.
   public static int buscarElemento(int elemento, int arr[]) {
       return buscarRec(elemento, arr, 0, arr.length - 1);
   }

   // Función recursiva auxiliar.
   private static int buscarRec(int elemento, int arr[], int idx0, int idx1) {
       return -1;
   }
   #+END_SRC

b. Implementar una versión recursiva de ~invertirCola()~ que no use estructuras
   auxiliares.
   # (0.5 pts.)

   Es posible de implementar sin introducir una función auxiliar
   ~invertirColaRec()~, pero no se penalizará su uso.

   #+BEGIN_SRC java
   public static void invertirCola(ColaInt cola) {
   }
   #+END_SRC

c. Implementar una función recursiva que reciba dos pilas de enteros y devuelva
   una tercera pila resultado de mezclar, alternando, las dos pilas.
   # (1 pt.)

   No se permite usar estructuras ni funciones auxiliares. Las pilas originales
   deben quedar en su orden original. Pre-condición: se garantiza que ambas
   pilas tienen el mismo número de elementos.

   #+BEGIN_SRC java
   public static PilaInt mezclarPilas(PilaInt p1, PilaInt p2) {
       return null;
   }
   #+END_SRC

   Ejemplo:

   #+BEGIN_EXAMPLE
   1.ª pila: 4 7 19 2 44 23
             ↑
             Tope

   2.ª pila: 98 43 17 1 3 41
             ↑
             Tope

   Resultado: 4 98 7 43 19 17 2 1 44 3 23 41
              ↑
              Tope
   #+END_EXAMPLE

d. /(Opcional)/ Implementar una versión recursiva de QuickSort:
   # (1 pt.)?

   #+BEGIN_SRC java :noweb-ref quickSort
   public static void quickSortRec(int arreglo[]) {
   }
   #+END_SRC

   Archivo adicional que se debe entregar: [[file:src/ungs/prog2/tp0/opcional/Ordenamientos.java][Ordenamientos.java]].


* Conjuntos
:PROPERTIES:
:CUSTOM_ID: ej3
:HTML_CONTAINER_CLASS: ejercicios
:header-args: :noweb-ref Ejercicio3 :noweb-sep "\n\n"
:END:

*Archivo:* [[file:src/ungs/prog2/tp0/Ejercicio3.java][Ejercicio3.java]].

a. Implementar una función que, dados dos [[#ConjuntoInt][conjuntos de enteros]], devuelva la
   unión de ambos.
   # (0.5 pts.)

   #+BEGIN_SRC java
   // Devuelve la unión de a y b, que quedan sin modificar.
   public static ConjuntoInt union(ConjuntoInt a, ConjuntoInt b) {
       return null;
   }
   #+END_SRC

b. Implementar una función que, dados dos conjuntos, devuelva la intersección
   de ambos.
   # (0.5 pts.)

   #+BEGIN_SRC java
   // Devuelve la intersección de a y b, que quedan sin modificar.
   public static ConjuntoInt interseccion(ConjuntoInt a, ConjuntoInt b) {
       return null;
   }
   #+END_SRC

c. Implementar una las dos funciones anteriores como una extensión de
   /ConjuntoInt/ (modifican el objeto actual en lugar de devolver uno nuevo).
   # (1 pt.)

   #+BEGIN_SRC java
   public class ConjuntoEj3 extends ConjuntoInt
   {
       // Añade al conjunto actual todos los elementos del Conjunto c.
       public void union(ConjuntoInt c) {
       }

       // Convierte al conjunto actual en la intersección con el Conjunto c.
       public void interseccion(ConjuntoInt c) {
       }
   }
   #+END_SRC


* Clases y objetos
:PROPERTIES:
:CUSTOM_ID: ej4
:HTML_CONTAINER_CLASS: ejercicios
:END:

*Archivo:* [[file:src/ungs/prog2/tp0/FechaSimple.java][FechaSimple.java]].

a. Completar la clase /FechaSimple/ que se documenta a continuación:

   #+BEGIN_SRC java :tangle prog2/tp0/FechaSimple.java
   package ungs.prog2.tp0;

   public class FechaSimple
   {
       private int dia;
       private int mes;
       private int año;

       // Función de validación: devuelve ‘true’ si dia/mes/año
       // es una fecha válida.
       //
       // FechaSimple es válida si ‘dia’ está entre 1 y 31, ‘mes’
       // entre 1 y 12 y ‘año’ entre 1 y 9999.
       //
       // Es decir, FechaSimple es una variante simplificada del calendario
       // gregoriano en la que todos los meses tienen el mismo número de días.
       private boolean validos(int dia, int mes, int año) {
           return false;
       }

       // Construye un objeto de tipo Fecha, usando la función
       // validos() para validar. Si la fecha no es válida, lanza
       // la excepción RuntimeException, incluyendo el valor de
       // la fecha inválida.
       public FechaSimple(int dia, int mes, int año) {
       }

       // Avanza la fecha un número días (se debe validar que
       // ‘numDias’ es un entero positivo).
       public void avanzarDias(int numDias) {
       }

       // Devuelve el número de días desde una fecha a otra. Devuelve
       // un valor positivo si this >= otra, negativo en caso contrario.
       public int diferencia(FechaSimple otra) {
           return 0;
       }

       @Override
       public String toString() {
           return format(dia, mes, año);
       }

       private String format(int dia, int mes, int año) {
           return dia + "/" + mes + "/" + año;
       }
   }
   #+END_SRC

b. /(Opcional)/ Refactorizar el código de /FechaSimple/ usando una clase base
   abstracta /BaseFecha/.

   #+BEGIN_SRC java
   package ungs.prog2.tp0;

   import ungs.prog2.tp0.opcional.BaseFecha;

   // Estos son los métodos específicos a FechaSimple.
   //
   // No se deben agregar métodos privados si tiene sentido
   // agregarlos a la propia clase base BaseFecha.

   public class FechaSimple extends BaseFecha
   {
       public FechaSimple(int dia, int mes, int año) {
           super(dia, mes, año);
       }

       @Override
       public void avanzarDias(int numDias) {
       }

       @Override
       public int diferencia(BaseFecha otra) {
           return 0;
       }

       @Override
       protected boolean validos(int dia, int mes, int año) {
           return false;
       }
   }
   #+END_SRC

   Archivo adicional que se debe crear y entregar:

     - =ungs/prog2/tp0/opcional/BaseFecha.java=

c. /(Opcional)/ Implementar /FechaGregoriana/ que hereda también de /BaseFecha/.

   # TODO: documentar clase.

   #+BEGIN_SRC java :tangle prog2/tp0/opcional/FechaGregoriana.java
   package ungs.prog2.tp0.opcional;

   public class FechaGregoriana // extends BaseFecha
   {
       // Ejercicio OPCIONAL. Cambiar RESUELTO a ‘true’ en caso de
       // implementarlo.
       public static final boolean RESUELTO = false;
   }
   #+END_SRC

   Archivo adicional que se debe crear y entregar:

     - =ungs/prog2/tp0/opcional/FechaGregoriana.java=


* Estructuras de datos
:PROPERTIES:
:UNNUMBERED: t
:END:

** La clase /ColaInt/
:PROPERTIES:
:CUSTOM_ID: ColaInt
:END:
#+BEGIN_SRC java :tangle prog2/tda/ColaInt.java :noweb yes
package ungs.prog2.tda;

import java.util.Deque;
import java.util.LinkedList;

public class ColaInt
{
    private Deque<Integer> elems;

    public ColaInt() {
        elems = new LinkedList<>();
    }

    public void encolar(int x) {
        elems.addLast(x);
    }

    public int desencolar() {
        return elems.removeFirst();
    }

    public int primero() {
        return elems.peekFirst();
    }

    public boolean vacia() {
        return elems.isEmpty();
    }
}
#+END_SRC


** La clase /PilaInt/
:PROPERTIES:
:CUSTOM_ID: PilaInt
:END:
#+BEGIN_SRC java :tangle prog2/tda/PilaInt.java :noweb yes
package ungs.prog2.tda;

import java.util.Deque;
import java.util.LinkedList;

public class PilaInt
{
    private Deque<Integer> elems;

    public PilaInt() {
        elems = new LinkedList<>();
    }

    public void apilar(int x) {
        elems.addFirst(x);
    }

    public int desapilar() {
        return elems.removeFirst();
    }

    public int tope() {
        return elems.peekFirst();
    }

    public boolean vacia() {
        return elems.isEmpty();
    }
}
#+END_SRC


** La clase /ConjuntoInt/
:PROPERTIES:
:CUSTOM_ID: ConjuntoInt
:END:
#+BEGIN_SRC java :tangle prog2/tda/ConjuntoInt.java :noweb yes
package ungs.prog2.tda;

import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;

public class ConjuntoInt implements Iterable<Integer>
{
    // NOTA: la clase Conjunto es iterable, por lo que se puede escribir:
    //
    //    for (int x : conj) { ... }
    //
    //    for (int x : this) { ... }

    private Set<Integer> elems;

    public ConjuntoInt() {
        elems = new TreeSet<>();
    }

    public boolean agregar(int x) {
        return elems.add(x);
    }

    public boolean pertenece(int x) {
        return elems.contains(x);
    }

    public boolean eliminar(int x) {
        return elems.remove(x);
    }

    public boolean vacio() {
        return elems.isEmpty();
    }

    public int tamaño() {
        return elems.size();
    }

    public Iterator<Integer> iterator() {
        return elems.iterator();
    }
}
#+END_SRC


* Tangle                                                           :noexport:
#+BEGIN_SRC java :noweb-ref package
package ungs.prog2.tp0;
#+END_SRC

#+BEGIN_SRC java :tangle prog2/tp0/Ejercicio1.java :noweb yes
<<package>>

import ungs.prog2.tda.ColaInt;
import ungs.prog2.tda.PilaInt;

public class Ejercicio1
{
    <<Ejercicio1>>
}
#+END_SRC

#+BEGIN_SRC java :tangle prog2/tp0/Ejercicio2.java :noweb yes
<<package>>

import ungs.prog2.tda.ColaInt;
import ungs.prog2.tda.PilaInt;

public class Ejercicio2
{
    <<Ejercicio2>>
}
#+END_SRC

#+BEGIN_SRC java :tangle prog2/tp0/Ejercicio3.java :noweb yes
<<package>>

import ungs.prog2.tda.ConjuntoInt;

public class Ejercicio3
{
    <<Ejercicio3>>
}
#+END_SRC

*** Opcionales
#+BEGIN_SRC java :tangle prog2/tp0/opcional/Ordenamientos.java :noweb yes
package ungs.prog2.tp0.opcional;

public class Ordenamientos
{
    // Ejercicio OPCIONAL. Cambiar RESUELTO a ‘true’ en caso de
    // implementarlo.
    public static final boolean RESUELTO = false;

    <<quickSort>>
}
#+END_SRC
